\color{black}
\section{Implementando con MVC}

Antes de continuar, entendamos un poco más el patrón de diseño MVC (Modelo - Vista - Controlador). Como se mencionó en el capítulo anterior, el modelo MVC permite hacer la separación de las capas de interfaz, modelo y lógica de control de esta. La programación por capas es un estilo de programación en la que el objetivo primordial es la separación de la lógica de negocios de la lógica de diseño, un ejemplo básico de esto es separar la capa de datos de la capa de presentación al usuario. La ventaja principal de este estilo, es que el desarrollo se puede llevar a cabo en varios niveles y en caso de algún cambio sólo se ataca al nivel requerido sin tener que revisar entre código mezclado. La división en capas reduce la complejidad, facilita la reutilización y acelera el proceso de ensamblar o desensamblar alguna capa, o sustituirla por otra distinta.

\section{Conceptos del MVC}

El nucleo de \textbf{FlavorPHP} es el MVC, un patrón de diseño muy popular que funciona en tres capas:

\begin{itemize}
	\item \textbf{Modelos}: Representan los datos que utiliza nuestra aplicación, es decir su lógica de negocios.
	\item \textbf{Vistas}: Visualizan el modelo e interactuando con los usuarios de estas.
	\item \textbf{Controladores}: Obtiene las acciones de los usuarios e invocan cambios en las vistas o en los modelos según sea necesario.
\end{itemize}

Cuando un usuario realiza una petición a nuestra aplicación Web, esta petición es hecha utilizando el protocolo HTTP, \textbf{FlavorPHP} redirecciona esta petición enviandola directamente a su respectivo controlador. Los controladores pueden interactuar con los modelos y llamar a las vistas (interfaces de usuario), estas últimas se muestran al usuario respondiendo a la petición inicial.

\section{URLs en FlavorPHP (routing)}

FlavorPHP utiliza una convención especial en sus URLs para que funcionen nuestras aplicaciones y permitir el acceso a los controladores y sus acciones.

Por ejemplo:

\begin{center}
\texttt{http://localhost/saludo/hola/pedro/}
\end{center}

De la URL anterior obtenemos:

\begin{itemize}
	\item Nuestra aplicación esta instalada en: \textbf{http://localhost/}.
	\item \textbf{FlavorPHP} invocará al \texttt{controlador} llamado \textbf{saludo}.
	\item \textbf{FlavorPHP} ejecutará el \texttt{método} \textbf{hola} del \texttt{controlador} \textbf{saludo}.
	\item \textbf{FlavorPHP} pasará al \texttt{método} \textbf{hola} del \texttt{controlador} \textbf{saludo} el parámetro \textbf{pedro}.
\end{itemize}

Como podemos notar, los URLs en \textbf{FlavorPHP} se componen de 4 elementos principales:

\begin{enumerate}
	\item URL base de la aplicación.
	\item Nombre del modelo.
	\item Nombre del método a ejecutar en el modelo.
	\item Parámetro (argumento) que se la pasa al método a ejecutar en el modelo.
\end{enumerate}

En base a estos 4 componentes principales, podemos realizar algunas combinaciones para hacer más fácil el uso de \textbf{FlavorPHP}.

\subsection{Llamar al controlador index}

Vemos que obtenemos al utilizar la siguiente URL:

\begin{center}
\texttt{http://localhost/}
\end{center}

Cuando se usa solo la URL base de la aplicación, \textbf{FlavorPHP} ejecuta el método \textbf{index} del controlador \textbf{index} sin ningún parámetro.

\subsubsection{Controlador index con parámetro}

Si deseamos pasar un parámetro numérico al método \textbf{index} del controlador \textbf{index}, podemos utilizar la siguiente URL:

\begin{center}
\texttt{http://localhost/10/}
\end{center}

De esta forma el método \textbf{index} trendrá como parámetro el número \textbf{10}. Esta función trabaja \textbf{sí y solo sí} es númerico el primer (y único) elemento después de la URL base de la aplicación.

\subsection{Invocar a los métodos index}

Todos los controladores por defecto deben tener su método index, por lo que si deseamos llamar estos métodos solo hay que poner el nombre del controlador y \textbf{FlavorPHP} se encargará de ejecutar el método index.

Por ejemplo:

\begin{center}
\texttt{http://localhost/usuario/}
\end{center}

Esta URL ejecutará el método \textbf{index} del controlador \textbf{usuario}.

\section{Hola mundo con FlavorPHP}

Para crear la aplicación que nos salude desde \textbf{FlavorPHP} vamos a seguir las convenciones aprendidas en la sección anterior.

La URL final será:

\begin{center}
\texttt{http://localhost/saludo/hola/pedro/}
\end{center}

Primero debemos crear nuestro controlador \texttt{saludo} y almacenarlo en la carpeta \textit{controllers} con la siguiente regla \texttt{nombreControlador\_controller.php}. 

Por lo que nuestro controlador se llamará \textbf{saludo\_controller.php}, no nos olvidemos de esta convención al nombrar nuestros controladores para que el framework pueda manejarlos correctamente.

En el código~\ref{lst:saludoController} podemos ver la estructura base que deben tener todos nuestros controladores.

\color{normal}
\begin{lstlisting}[frame=tb, caption=saludo\_controller.php, label=lst:saludoController, showspaces=false]{}
class saludo_controller extends appcontroller {
		public function __construct() {
			parent::__construct();
				
		}
	  public function index($id=NULL) {	}	
}
\end{lstlisting}
\color{black}

Si en estos momentos llamamos a la URL \texttt{http://localhost/saludo/} veremos en blanco nuestro navegador, debido a que aun no generamos ninguna vista.

Agreguémosle lo siguiente (código~\ref{lst:saludoController2}) a nuestro controlador:

\color{normal}
\begin{lstlisting}[frame=tb, caption=Controlador saludo incorrecto, label=lst:saludoController2, showspaces=false]{}
class saludo_controller extends appcontroller {
		public function __construct() {
			parent::__construct();
				
		}
		public function index($id=null){
			echo '<h1>Hola Mundo</h1>';
		}
	}\end{lstlisting}
\color{black}

Si refrescamos (F5) nuestro navegador veremos el texto '\texttt{Hola Mundo}'. Pero, \textbf{¡esto no es correcto!} debemos crear una vista desde la cual se muestre la información al usuario.

Para generar la vista, debemos crear una carpeta nueva dentro de la carpeta \texttt{views}, esta nueva carpeta debe llamarse exactamente igual que el controlador, en este caso quedará \textit{./views/\textbf{saludo}/}, dentro de esta carpeta debemos crear un archivo que se llame igual que el método llamado, para este ejemplo el archivo debe ser \textit{./views/saludo/\textbf{index.php}} (código~\ref{lst:indexView}).

\color{normal}
\begin{lstlisting}[frame=tb, caption=vista index del controlador saludo, label=lst:indexView, showspaces=false]{}
<h1>Hola mundo</h1>
\end{lstlisting}
\color{black}

Una vez creada la vista modificamos el controlador para mostrarla.

\color{normal}
\begin{lstlisting}[frame=tb, caption=Controlador saludo correcto, label=lst:saludoController3, showspaces=false]{}
class saludo_controller extends appcontroller {
		public function __construct() {
			parent::__construct();
				
		}
		public function index($id=null){
			$this->render();
		}
	}\end{lstlisting}
\color{black}

Al usar la instrucción \texttt{render()} automáticamente \textbf{FlavorPHP} sabrá cual vista buscar y la mostrará al usuario.

Ahora que ya entendemos mejor como utilizar el framework, volvamos al objetivo inicial.

A nuestro controlador saludo le agregaremos el método \textbf{hola} que recibirá un parámetro de nombre \textbf{msg} (código~\ref{lst:saludoHola}). Este parámetro será asignado a la vista para que lo despliegue junto a un saludo.

\color{normal}
\begin{lstlisting}[frame=tb, caption=Método hola, label=lst:saludoHola, showspaces=false]{}
class saludo_controller extends appcontroller {
		public function __construct() {
			parent::__construct();		
		}
		public function index($id=null){
			$this->render();
		}
		public function hola($msg){
			$this->view->nombre = $msg;
			$this->render();
		}
	}\end{lstlisting}
\color{black}

La vista (\textit{./views/saludo/\textbf{hola.php}}) quedará como muestra el código~\ref{lst:saludoHolaVista}

\color{normal}
\begin{lstlisting}[frame=tb, caption=Vista del método hola, label=lst:saludoHolaVista, showspaces=false]{}
<h1>Hola <?php echo $nombre; ?></h1>
\end{lstlisting}
\color{black}

Como podemos observar, al asignarle en nuestros controladores una variable a nuestro objeto \textbf{\$this-$>$view}, la podemos utilizar desde la vista, haciendo uso de PHP.